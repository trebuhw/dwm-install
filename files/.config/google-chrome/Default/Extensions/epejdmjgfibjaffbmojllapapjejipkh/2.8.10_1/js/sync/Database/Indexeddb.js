function SQLResultSet(){this.insertId="",this.rows=[],this.rowsAffected=0}function IndexedDBHandler(){this.isConnected=null,this.transaction=null,this.db=null}IndexedDBHandler.prototype={connect(){const request=indexedDB.open("SamsungSCloudSyncStorage",3);request.onupgradeneeded=event=>{const db=event.target.result;db.onerror=event=>{console.log(event)};const stores=db.objectStoreNames;let bookmarkStore,tabStore;bookmarkStore=stores.contains("BOOKMARKS")?event.target.transaction.objectStore("BOOKMARKS"):db.createObjectStore("BOOKMARKS",{keyPath:"_ID"}),bookmarkStore.indexNames.contains("_ID")||bookmarkStore.createIndex("_ID","_ID",{unique:!0}),bookmarkStore.indexNames.contains("POSITION")||bookmarkStore.createIndex("POSITION","POSITION"),bookmarkStore.indexNames.contains("SYNC3")||bookmarkStore.createIndex("SYNC3","SYNC3"),bookmarkStore.indexNames.contains("SYNC4")||bookmarkStore.createIndex("SYNC4","SYNC4"),bookmarkStore.indexNames.contains("FOLDER")||bookmarkStore.createIndex("FOLDER","FOLDER"),bookmarkStore.indexNames.contains("IS_DELETED")||bookmarkStore.createIndex("IS_DELETED","IS_DELETED"),bookmarkStore.indexNames.contains("ACCOUNT_TYPE")||bookmarkStore.createIndex("ACCOUNT_TYPE","ACCOUNT_TYPE"),bookmarkStore.indexNames.contains("ACCOUNT_NAME")||bookmarkStore.createIndex("ACCOUNT_NAME","ACCOUNT_NAME"),bookmarkStore.indexNames.contains("DIRTY")||bookmarkStore.createIndex("DIRTY","DIRTY"),bookmarkStore.indexNames.contains("TITLE")||bookmarkStore.createIndex("TITLE","TITLE"),bookmarkStore.indexNames.contains("PARENT")||bookmarkStore.createIndex("PARENT","PARENT"),bookmarkStore.indexNames.contains("URL")||bookmarkStore.createIndex("URL","URL"),tabStore=stores.contains("TABS")?event.target.transaction.objectStore("TABS"):db.createObjectStore("TABS",{keyPath:"_ID"}),tabStore.indexNames.contains("_ID")||tabStore.createIndex("_ID","_ID",{unique:!0}),tabStore.indexNames.contains("ACCOUNT_NAME")||tabStore.createIndex("ACCOUNT_NAME","ACCOUNT_NAME"),tabStore.indexNames.contains("ACCOUNT_TYPE")||tabStore.createIndex("ACCOUNT_TYPE","ACCOUNT_TYPE"),tabStore.indexNames.contains("DEVICE_ID")||tabStore.createIndex("DEVICE_ID","DEVICE_ID"),tabStore.indexNames.contains("DEVICE_NAME")||tabStore.createIndex("DEVICE_NAME","DEVICE_NAME"),tabStore.indexNames.contains("DIRTY")||tabStore.createIndex("DIRTY","DIRTY"),tabStore.indexNames.contains("IS_DELETED")||tabStore.createIndex("IS_DELETED","IS_DELETED"),tabStore.indexNames.contains("IS_INCOGNITO")||tabStore.createIndex("IS_INCOGNITO","IS_INCOGNITO"),tabStore.indexNames.contains("TAB_ACTIVATE")||tabStore.createIndex("TAB_ACTIVATE","TAB_ACTIVATE"),tabStore.indexNames.contains("TAB_ID")||tabStore.createIndex("TAB_ID","TAB_ID"),tabStore.indexNames.contains("TAB_INDEX")||tabStore.createIndex("TAB_INDEX","TAB_INDEX"),tabStore.indexNames.contains("TAB_TITLE")||tabStore.createIndex("TAB_TITLE","TAB_TITLE"),tabStore.indexNames.contains("TAB_URL")||tabStore.createIndex("TAB_URL","TAB_URL"),tabStore.indexNames.contains("SYNC5")||tabStore.createIndex("SYNC5","SYNC5")},request.onsuccess=async()=>{this.db=request.result,this.db.addEventListener("close",(()=>{console.log("Database connection closed")})),this.isConnected=!0},request.onerror=error=>{console.log(error),SamsungSCloudSyncService.SyncLogs.log("Connect to database error "+error.message),this.isConnected=!1}},async waitConnected(){const delay=time=>new Promise((res=>setTimeout(res,time)));for(;null===this.isConnected;)await delay(200);return!0},updateAll(Uri,items,calback){this.transaction=this.db.transaction([Uri],"readwrite").objectStore(Uri)},cancelUpdateAll(calback){this.transaction.abort()},getRequestByIndex(store,selection){let request;const indexedKey=selection&&selection.equals&&selection.equals.length>0?selection.equals[0].key:null;if(indexedKey){const index=store.index(indexedKey),indexedValue=selection.equals[0].value;try{request=index.getAll(IDBKeyRange.only(indexedValue))}catch(error){console.log("getAll ",error,indexedValue)}}return request||(request=store.getAll()),request},filter(items,selection,projection){let equals=[],likes=[],ins=[],not_likes=[],empty=[],rows=items;if(selection&&(selection.equals&&(equals=selection.equals),selection.likes&&(likes=selection.likes),selection.ins&&(ins=selection.ins),selection.not_likes&&(not_likes=selection.not_likes),selection.empty&&(empty=selection.empty)),equals.length&&equals.forEach((item=>{rows=rows.filter((rowItem=>rowItem[item.key]==item.value))})),likes.length&&likes.forEach((item=>{rows=rows.filter((rowItem=>rowItem[item.key].indexOf(item.value)>=0))})),ins.length&&ins.forEach((item=>{rows=rows.filter((rowItem=>item.value.map((val=>val+"")).indexOf(rowItem[item.key]+"")>=0))})),not_likes.length&&not_likes.forEach((item=>{rows=rows.filter((rowItem=>rowItem[item.key].indexOf(item.value)<0))})),empty.length&&empty.forEach((item=>{rows=rows.filter((rowItem=>null==rowItem[item.key]||null==rowItem[item.key]||""==rowItem[item.key]))})),projection&&projection.length&&Array.isArray(projection)){const prj=projection.filter((p=>p.indexOf(" as ")>0));if(prj.length){const projectionMap=[];prj.forEach((p=>{projectionMap.push(p.split("as"))})),rows.forEach((row=>{projectionMap.forEach((p=>{row[p[1].trim()]=row[p[0].trim()]}))}))}}return rows.sort(((r1,r2)=>{if(r1.POSITION&&r2.POSITION){if(r1.POSITION>r2.POSITION)return 1;if(r1.POSITION<r2.POSITION)return-1}else{if(r1.CREATED>r2.CREATED)return 1;if(r1.CREATED<r2.CREATED)return-1}return 0})),rows},query(Uri,projection,selection,sortOrder){return new Promise((async(resolve,reject)=>{await this.waitConnected();const store=this.db.transaction([Uri],"readwrite").objectStore(Uri),result=new SQLResultSet;let getRequest=this.getRequestByIndex(store,selection);getRequest.onsuccess=ev=>{let rows=getRequest.result&&getRequest.result.value?getRequest.result.value:getRequest.result||[];rows.length?result.rows=this.filter(rows,selection,projection):result.rows=rows,resolve(result)},getRequest.onerror=error=>{reject(error)}}))},async add(Uri,item,calback){await this.waitConnected();const store=this.db.transaction([Uri],"readwrite").objectStore(Uri),result=new SQLResultSet;var cursor=store.index("_ID").openCursor(null,"prev");cursor.onsuccess=event=>{const maxId=event?.target?.result?.value?._ID||0;item.IS_DELETED||(item.IS_DELETED="0"),item._ID||(item._ID=maxId+1);const request=store.add(item);request.onsuccess=()=>{result.rows.push(item),result.rowsAffected=1,calback(result)},request.onerror=ev=>{console.log("(IndexedDB add) Error: ",ev),calback(result)}},cursor.onerror=event=>{console.log("(IndexedDB add) Error: ",event),calback(result)}},update(Uri,VALUES,selection){return new Promise((async(resolve,reject)=>{await this.waitConnected();const transaction=this.db.transaction([Uri],"readwrite"),store=transaction.objectStore(Uri),result=new SQLResultSet;let getRequest=this.getRequestByIndex(store,selection);getRequest.onsuccess=ev=>{let items,rows=getRequest.result&&getRequest.result.value?getRequest.result.value:getRequest.result||[];if(items=rows.length?this.filter(rows,selection,null):rows,!items||0==items.length)return resolve(result);const _IDs=[IMPORTED_FOLDER_IDS.CHROME,IMPORTED_FOLDER_IDS.EDGE,IMPORTED_FOLDER_IDS.OPERA];items.forEach((item=>{const id=item._ID,_item=Object.assign({},item,VALUES),request=store.put(_item);request.onsuccess=()=>{result.rows.push(_item),_IDs.includes(_item._ID)&&!_IDs.includes(id)&&store.delete(id)},request.onerror=ev=>{reject(ev)}}))},getRequest.onerror=error=>{reject(error)},transaction.oncomplete=()=>{resolve(result)}}))},UpdateMultiple(Uri,updateItems,selection){return new Promise((async(resolve,reject)=>{await this.waitConnected();const transaction=this.db.transaction([Uri],"readwrite"),store=transaction.objectStore(Uri),result=new SQLResultSet;let getRequest=this.getRequestByIndex(store,selection);getRequest.onsuccess=()=>{let items,rows=getRequest.result&&getRequest.result.value?getRequest.result.value:getRequest.result||[];if(items=rows.length?this.filter(rows,selection,null):rows,!items||0==items.length)return resolve(result);items.forEach((item=>{const _item=Object.assign({},item,updateItems[item._ID]),request=store.put(_item);request.onsuccess=()=>{result.rows.push(item)},request.onerror=ev=>{reject(ev)}}))},getRequest.onerror=error=>{reject(error)},transaction.oncomplete=()=>{resolve(result)}}))},async del(Uri,selection){return new Promise((async(resolve,reject)=>{await this.waitConnected();const item=(await this.query(Uri,null,selection)).rows,result=new SQLResultSet;if(item&&item.length){const transaction=this.db.transaction([Uri],"readwrite"),store=transaction.objectStore(Uri);item.forEach((i=>{store.delete(i._ID),result.rows.push(i)})),transaction.oncomplete=()=>{resolve(result)}}else resolve(result)}))},async getMax(Uri,key,selection){return new Promise((async(resolve,reject)=>{await this.waitConnected();const items=(await this.query(Uri,null,selection)).rows;let max="";items.forEach((item=>{(!max||max<item[key])&&(max=item[key])})),resolve(max>0?max:0)}))},async getMaxValueByKey(Uri,key){return new Promise((async(resolve,reject)=>{await this.waitConnected();var cursor=this.db.transaction([Uri],"readonly").objectStore(Uri).index(key).openCursor(null,"prev");cursor.onsuccess=event=>{event.target&&event.target.result&&event.target.result.value?resolve(event.target.result.value[key]>=0?event.target.result.value[key]:0):resolve(0)},cursor.onerror=event=>{resolve(0)}}))},clear(Uri){try{const transaction=this.db.transaction(["BOOKMARKS","TABS"],"readwrite");if(Uri){transaction.objectStore(Uri).clear()}else{const bookmarksStore=transaction.objectStore("BOOKMARKS"),tabsStore=transaction.objectStore("TABS");bookmarksStore.clear(),tabsStore.clear()}}catch(error){console.log(error)}}};