async function onTabDeleteConfirm(e,target){const dividerTarget=tabsyncDataContainer.querySelector(".divider-tab-item");await storageLocalApi.removeItem(LAST_IMPORT_TIME);const{id:tabId,isFolder:isFolder,title:title}=target.dataset;removeDeviceOrTab("true"==isFolder)("true"==isFolder?title:parseInt(tabId)).then((()=>removeFromDOM(target.parentNode))).then((()=>removeFromDOM(dividerTarget))).then(doTabSync)}const removeDeviceOrTab=folder=>folder?removeTabDevice:invalidateTabUrl;function invalidateTabUrl(_ID){return DB.Update.tabs({newData:{DIRTY:1,IS_DELETED:"1",SYNC5:0},where:{equals:[{key:"_ID",value:_ID}]}})}function removeChildren(results){const removePromises=Array.from(results).map((({_ID:_ID})=>removeDeviceOrTab(!1)(_ID)));return Promise.all(removePromises)}function removeTabDevice(title){return new Promise(((resolve,reject)=>DB.Query.tabs({selection:["_ID"],where:{equals:[{key:"DEVICe_NAME",value:title}]}}).then(removeChildren).then(resolve)))}function doTabSync(){isOpenTabsSyncOn()?chrome.runtime.sendMessage({BUTTON:"TAB_SYNC"}):renderTabs()}function onDeleteTabConfirm_fancytree(e,target){const{id:id,isFolder:isFolder,title:title}=target.dataset;"true"==isFolder?removeTabDevice(title).then(doTabSync):invalidateTabUrl(id).then(doTabSync)}function onDeleteMultiTabConfirm_fancytree(tabs){removeChildren(tabs).then(doTabSync)}